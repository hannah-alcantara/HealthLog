# Data Model: Healthcare Tracking Application (Convex)

**Feature**: Healthcare Tracking Application
**Branch**: `001-health-log`
**Date**: 2026-02-06

## Overview

This document defines the data entities, Convex schema definitions, TypeScript types, and client-side Zod validation schemas for the healthcare tracking application using Convex as the backend.

---

## Convex Schema Definitions

### Database Schema (`convex/schema.ts`)

```typescript
import { defineSchema, defineTable } from "convex/server";
import { v } from "convex/values";

export default defineSchema({
  symptoms: defineTable({
    userId: v.id("users"),           // Owner (authenticated or anonymous)
    symptomType: v.string(),         // e.g., "Headache", "Nausea", "Fatigue"
    severity: v.number(),            // 1-10 scale
    bodyPart: v.optional(v.string()), // e.g., "Head", "Stomach", "Back"
    triggers: v.optional(v.string()), // Possible triggers (freeform text)
    notes: v.optional(v.string()),    // Additional notes
    loggedAt: v.number(),            // Unix timestamp (milliseconds)
  })
    .index("by_user", ["userId"])
    .index("by_user_and_date", ["userId", "loggedAt"]),

  appointments: defineTable({
    userId: v.id("users"),
    date: v.number(),                // Unix timestamp for appointment date
    doctorName: v.string(),
    reason: v.string(),              // Reason for visit
    symptoms: v.optional(v.string()), // Freeform text describing current symptoms
    notes: v.optional(v.string()),    // Doctor notes or follow-up info
    generatedQuestions: v.optional(v.array(v.string())), // AI-generated questions
  })
    .index("by_user", ["userId"])
    .index("by_user_and_date", ["userId", "date"]),
});
```

**Key Design Decisions**:
- **Timestamps as numbers**: Convex uses Unix timestamps (milliseconds) for efficient querying and sorting
- **Indexes**: Primary access pattern is "all records for user, sorted by date"
- **Optional fields**: Use `v.optional()` for nullable fields
- **System fields**: Convex automatically provides `_id` (unique), `_creationTime` (Unix timestamp)
- **No explicit `createdAt`/`updatedAt`**: Use `_creationTime` system field

---

## Entity Definitions

### 1. Symptom

Represents a logged symptom with severity and contextual information.

**Convex Validator**:
```typescript
// convex/symptoms.ts
import { v } from "convex/values";

export const symptomValidator = {
  symptomType: v.string(),
  severity: v.number(),
  bodyPart: v.optional(v.string()),
  triggers: v.optional(v.string()),
  notes: v.optional(v.string()),
  loggedAt: v.number(),
};
```

**TypeScript Type** (from Convex schema):
```typescript
// Generated by Convex
import { Doc } from "./_generated/dataModel";

export type Symptom = Doc<"symptoms">;

// Symptom structure:
// {
//   _id: Id<"symptoms">,
//   _creationTime: number,
//   userId: Id<"users">,
//   symptomType: string,
//   severity: number,
//   bodyPart?: string,
//   triggers?: string,
//   notes?: string,
//   loggedAt: number,
// }
```

**Client-side Zod Schema** (`lib/schemas/symptom.ts`):
```typescript
import { z } from 'zod';

export const symptomSchema = z.object({
  symptomType: z.string().min(1, 'Symptom type is required').max(200).trim(),
  severity: z.number().min(1, 'Severity must be at least 1').max(10, 'Severity cannot exceed 10'),
  bodyPart: z.string().max(100).trim().optional(),
  triggers: z.string().max(500).trim().optional(),
  notes: z.string().max(2000).trim().optional(),
  loggedAt: z.number(), // Unix timestamp
});

export type CreateSymptomInput = z.infer<typeof symptomSchema>;
```

**Validation Rules**:
- `symptomType`: Required, 1-200 characters, trimmed
- `severity`: Required, integer 1-10
- `bodyPart`: Optional, max 100 characters
- `triggers`: Optional, max 500 characters
- `notes`: Optional, max 2000 characters
- `loggedAt`: Unix timestamp in milliseconds

---

### 2. Appointment

Represents a medical appointment with optional symptoms and AI-generated questions.

**Convex Validator**:
```typescript
// convex/appointments.ts
import { v } from "convex/values";

export const appointmentValidator = {
  date: v.number(),
  doctorName: v.string(),
  reason: v.string(),
  symptoms: v.optional(v.string()),
  notes: v.optional(v.string()),
  generatedQuestions: v.optional(v.array(v.string())),
};
```

**TypeScript Type**:
```typescript
import { Doc } from "./_generated/dataModel";

export type Appointment = Doc<"appointments">;

// Appointment structure:
// {
//   _id: Id<"appointments">,
//   _creationTime: number,
//   userId: Id<"users">,
//   date: number,
//   doctorName: string,
//   reason: string,
//   symptoms?: string,
//   notes?: string,
//   generatedQuestions?: string[],
// }
```

**Client-side Zod Schema** (`lib/schemas/appointment.ts`):
```typescript
import { z } from 'zod';

export const appointmentSchema = z.object({
  date: z.number(), // Unix timestamp
  doctorName: z.string().min(1, 'Doctor name is required').max(200).trim(),
  reason: z.string().min(1, 'Reason for visit is required').max(500).trim(),
  symptoms: z.string().max(2000).trim().optional(),
  notes: z.string().max(2000).trim().optional(),
  generatedQuestions: z.array(z.string()).optional(),
});

export type CreateAppointmentInput = z.infer<typeof appointmentSchema>;
```

**Validation Rules**:
- `date`: Required, Unix timestamp
- `doctorName`: Required, 1-200 characters, trimmed
- `reason`: Required, 1-500 characters, trimmed
- `symptoms`: Optional, max 2000 characters
- `notes`: Optional, max 2000 characters
- `generatedQuestions`: Optional array of strings

---

## Convex Functions (Queries & Mutations)

### Symptom Queries

```typescript
// convex/symptoms.ts
import { query, mutation } from "./_generated/server";
import { v } from "convex/values";

// Get all symptoms for current user
export const getAll = query({
  args: {},
  handler: async (ctx) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) return [];

    return await ctx.db
      .query("symptoms")
      .withIndex("by_user_and_date", (q) => q.eq("userId", identity.subject))
      .order("desc")
      .collect();
  },
});

// Get recent symptoms (for dashboard)
export const getRecent = query({
  args: { limit: v.optional(v.number()) },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) return [];

    return await ctx.db
      .query("symptoms")
      .withIndex("by_user_and_date", (q) => q.eq("userId", identity.subject))
      .order("desc")
      .take(args.limit ?? 30);
  },
});

// Get symptoms by date range
export const getByDateRange = query({
  args: { startDate: v.number(), endDate: v.number() },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) return [];

    const symptoms = await ctx.db
      .query("symptoms")
      .withIndex("by_user_and_date", (q) => q.eq("userId", identity.subject))
      .filter((q) =>
        q.and(
          q.gte(q.field("loggedAt"), args.startDate),
          q.lte(q.field("loggedAt"), args.endDate)
        )
      )
      .collect();

    return symptoms;
  },
});
```

### Symptom Mutations

```typescript
// Create symptom
export const create = mutation({
  args: {
    symptomType: v.string(),
    severity: v.number(),
    bodyPart: v.optional(v.string()),
    triggers: v.optional(v.string()),
    notes: v.optional(v.string()),
    loggedAt: v.number(),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new Error("Unauthorized");

    const symptomId = await ctx.db.insert("symptoms", {
      userId: identity.subject as any,
      ...args,
    });

    return symptomId;
  },
});

// Update symptom
export const update = mutation({
  args: {
    id: v.id("symptoms"),
    symptomType: v.optional(v.string()),
    severity: v.optional(v.number()),
    bodyPart: v.optional(v.string()),
    triggers: v.optional(v.string()),
    notes: v.optional(v.string()),
    loggedAt: v.optional(v.number()),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new Error("Unauthorized");

    const { id, ...updates } = args;

    // Verify ownership
    const existing = await ctx.db.get(id);
    if (!existing || existing.userId !== identity.subject) {
      throw new Error("Symptom not found or unauthorized");
    }

    await ctx.db.patch(id, updates);
    return id;
  },
});

// Delete symptom
export const remove = mutation({
  args: { id: v.id("symptoms") },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new Error("Unauthorized");

    // Verify ownership
    const existing = await ctx.db.get(args.id);
    if (!existing || existing.userId !== identity.subject) {
      throw new Error("Symptom not found or unauthorized");
    }

    await ctx.db.delete(args.id);
  },
});
```

### Appointment Functions

Similar structure for appointments (create, update, delete, getAll, getByDateRange).

---

## Data Migration from localStorage

### Migration Script (`lib/utils/migrate-to-convex.ts`)

```typescript
import { api } from "@/convex/_generated/api";
import { ConvexReactClient } from "convex/react";

interface LocalStorageSymptom {
  id: string;
  symptomType: string;
  severity: number;
  bodyPart?: string | null;
  triggers?: string | null;
  notes?: string | null;
  loggedAt: string; // ISO 8601
}

export async function migrateLocalStorageToConvex(convex: ConvexReactClient) {
  // Load localStorage data
  const symptomsRaw = localStorage.getItem('health-log:symptoms');
  const appointmentsRaw = localStorage.getItem('health-log:appointments');

  if (!symptomsRaw && !appointmentsRaw) {
    return { success: true, migratedCount: 0 };
  }

  let migratedCount = 0;

  // Migrate symptoms
  if (symptomsRaw) {
    const symptoms: LocalStorageSymptom[] = JSON.parse(symptomsRaw);

    for (const symptom of symptoms) {
      await convex.mutation(api.symptoms.create, {
        symptomType: symptom.symptomType,
        severity: symptom.severity,
        bodyPart: symptom.bodyPart || undefined,
        triggers: symptom.triggers || undefined,
        notes: symptom.notes || undefined,
        loggedAt: new Date(symptom.loggedAt).getTime(),
      });
      migratedCount++;
    }
  }

  // Migrate appointments (similar logic)

  // Clear localStorage after successful migration
  localStorage.removeItem('health-log:symptoms');
  localStorage.removeItem('health-log:appointments');

  return { success: true, migratedCount };
}
```

---

## Frontend React Hooks

### Using Convex Queries

```typescript
// components/symptoms/symptoms-list.tsx
import { useQuery } from "convex/react";
import { api } from "@/convex/_generated/api";

export function SymptomsList() {
  const symptoms = useQuery(api.symptoms.getAll);

  if (symptoms === undefined) {
    return <LoadingSkeleton />;
  }

  return (
    <div>
      {symptoms.map((symptom) => (
        <SymptomCard key={symptom._id} symptom={symptom} />
      ))}
    </div>
  );
}
```

### Using Convex Mutations

```typescript
// components/symptoms/symptom-form.tsx
import { useMutation } from "convex/react";
import { api } from "@/convex/_generated/api";

export function SymptomForm() {
  const createSymptom = useMutation(api.symptoms.create);

  const handleSubmit = async (data: CreateSymptomInput) => {
    await createSymptom({
      ...data,
      loggedAt: Date.now(),
    });

    toast.success("Symptom logged successfully");
  };

  return <form onSubmit={handleSubmit}>{/* form fields */}</form>;
}
```

---

## Schema Synchronization

**Important**: Convex validators and Zod schemas must be kept in sync manually.

| Field | Convex Type | Zod Schema |
|-------|-------------|------------|
| `symptomType` | `v.string()` | `z.string().min(1).max(200)` |
| `severity` | `v.number()` | `z.number().min(1).max(10)` |
| `bodyPart` | `v.optional(v.string())` | `z.string().max(100).optional()` |
| `triggers` | `v.optional(v.string())` | `z.string().max(500).optional()` |
| `notes` | `v.optional(v.string())` | `z.string().max(2000).optional()` |
| `loggedAt` | `v.number()` | `z.number()` |

**Validation Flow**:
1. **Client-side**: Zod validates form input before submission
2. **Server-side**: Convex validators enforce runtime type safety
3. **Database**: Convex schema ensures data integrity

---

## Size Estimates

**Per Entity Storage** (approximate):
- Symptom: ~300 bytes (avg, including indexes)
- Appointment: ~500 bytes (avg, including generatedQuestions)

**Typical Dataset** (500 entries):
- 500 symptoms: ~150KB
- 50 appointments: ~25KB

**Total**: ~175KB (well within Convex free tier limits)

**Convex Free Tier**:
- Database storage: 1GB
- Bandwidth: 5GB/month
- Sufficient for thousands of users

---

## Schema Files Location

```
convex/
├── schema.ts           # Central schema definition
├── symptoms.ts         # Symptom queries and mutations
└── appointments.ts     # Appointment queries and mutations

lib/schemas/
├── symptom.ts          # Client-side Zod validation
└── appointment.ts      # Client-side Zod validation
```

---

## References

- [Convex Schema Documentation](https://docs.convex.dev/database/schemas)
- [Convex Query/Mutation Documentation](https://docs.convex.dev/functions)
- [Convex Authentication](https://docs.convex.dev/auth)
- [Convex React Integration](https://docs.convex.dev/client/react)
